#pragma once
#include <vector>
#include <deque>
#include <cassert>
#include <memory>
#include <algorithm>
#include "Assembly.h"
#include "Spinlock.h"
#include "LoaderObjects.h"

//TODO support base class (including virtual function support)
/*

	Basic ideas:
	1. Base class is constructed after the construction of derived type but
	   must be loaded (up to LoadFields) before. This avoids the need to check
	   cyclic base class separately. Interface can be loaded later. 
	2. Abstract generic class can have a 'derived' argument
		abstract class Animal<derived T> ...
		This is a front-end feature. We don't need to care too much here...
	3. Virtual function call is done through a pointer to global storage.
	4. Each class assign a global type for vtab. It will be automatically
	   included in the RuntimeObject layout. The type of functions are checked
	   when loading to match the base class.
	-. Allow pointer to a global storage type.
	6. Native type for managed function only with generic.
		Maybe we need to have a RefParam<T> type besides Pointer<T> to indicate
		it's a ref parameter (so we can do some optimization/transformation).
	7. Unmanaged function pointer don't need to be wrapped to function type.
	   Delegate like C# should be fine. Managed function type is only internal use.

*/
//TODO pay attention to the following C# code (note it's not possible to do the same in C++)
/*
		class A<T> : List<A<List<T>>>
		{
		}
		A<int> x;
		void X()
		{
			var val = x[0][0][0][0][0][0][0][0][0][0][0];
		}
*/
//Two solusion:
//1. Disallow (by limiting simultaneously loading types)
//2. Allow incomplete type. Only call LoadFields when needed. (Need major change in structure.)


/*
Traits: we want the following:

//T is the type that should have all the requirements, TElement is generic parameter
traits TestTraits<TElement>(T)
{
	//Requires self type to have function/field
	bool MoveNext(); //Normal function
	TElement Current_get(); //Referencing a generic parameter
	static int Compare(T, T); //Referencing self
	void AddList(List<T>); //Equals to: requires _someType = List<T>; void AddList(_someType);
	int Length; //Field (need field table)

	//Requires another type to exist
	requires _intType = T::IntType; //An alias. Scope of _intType is within this traits definition
	requires T::TemplateType<int>; //A template alias
	requires List<T>; //Another type

	//Refer to another traits
	requires _intType : ValueType;
	requires _intType : new(); //System defined traits Constructible()

	//Requires another type to have function
	//Compiles to a new traits and a declaration of Stream on that traits
	requires Stream
	{
		//Note that in the case Stream.Write has multiple overload and containing a Write(object),
		//the exact overload is chosen for each T, instead of always use Write(object). See below.
		void Write(T);
	}
}


traits _someAutoGeneratedTraits<T1>(T)
{
	void Write(T1);
}

traits TestTraits(T)
{
	requires Stream : _someAutoGeneratedTraits<T>;
}

*/

/*

Parameter pack

Can only contain one parameter pack (don't need to be the last)

void F1<T1, T2...>(T1 a, Tuple<T2>... b);
void F2<T1, T2...>(T1 a, Tuple<T2...> b);

Generic parameter:
[0] T1
[1] T2
---
[2] T2...

Tuple<T2>... = Tuple<[1]>
Tuple<T2...> = Tuple<[2]>

void F1<T1..., T2>(T2 a, Tuple<T1>... b);
void F2<T1..., T2>(T2 a, Tuple<T1...> b);

Generic parameter:
[0] T1
[1] T2
---
[2] T1...

Tuple<T1>... = Tuple<[0]>
Tuple<T1...> = Tuple<[2]>

Because constrains can only be applied on single type, it can only be applied to [0] and [1].

*/

//Roadmap (traits)
//TODO base type/interface constrain
//TODO trait constrain framework
//TODO trait function
//TODO trait field
//TODO trait export
//TODO import/export traits impl & test

//Roadmap (common)
//TODO Traits (see above)
//  for generic type's member, function must inherits parameters
//  (when looking for members, these parameters are directly
//  copied from type's parameters, before constrain is checked)
//TODO Reference of trait function, type
//TODO Type parital specialization
//TODO Remove direct export of function and fields
//TODO GenericDeclaration with parameter pack (see above)
//TODO Support for variable sized object (string, array)
//TODO Allow a function to use REF_SELF to refer to itself

//Roadmap (interpreter)
//TODO RuntimeObject layout

//Roadmap (low priority)
//TODO Test cases for type loading with base/interfaces, box type
//TODO Public API for loading subtype
//TODO Test cases for subtype loading, with cyclic reference

//New types of type reference in constrain type list
//  Parent: parent type itself (only for type).
//  Alias: subtype alias of another type in constrain list.
//  Any: any type, which is to be determined by matching.
//    traits A<T1>(T)...; ... requires T : A;
//    Implicitly => T1: any, T : A<T1>

//New types of function reference in constrain function list
//  Member: member function of a type (with give param and ret types)

//To allow the parent GenericDeclaration to refer to a type/function
//in one of its constrains, we organize each constrain as a tree,
//like a file system. Each constrain 'export' either one type (file)
//or one of its sub constrain (folder). In the parent GD, we specify
//a path to recursively index through this tree and find the type
//we need. Each level, the exporting use a string as a name to allow
//binary compatibility across versions.
/*
traits A(T)
{
	requires Stream : B<T>;
}
traits B<T1>(T)
{
	void Write(T1);
}

translates to:
A {
	Types:
	[0] self
	[1] Stream
	Sub-traits:
	#0 on [1] with B<[0]>
	Export traits:
	"Stream" : #0
}
B {
	Types:
	[0] empty
	[1] argument 0
	Functions:
	#0: "Write": ret [0]. args { [1] }
	Export functions:
	"Write" : #0
}

If one generic declaration is 
	<T> requires T : A
translates to:
	#0: constrain A on arg 0
Reference of Stream.Write is:
	#0/Stream/Write
*/

//Note: vtab will be copied from StaticPointer for each type using it, after initializer is executed. 
//Further modification will not have any effect.
//First ? bit in interface vtab is the offset, which is not included in the TSM_GLOBAL type layout,
//but is automatically added. Field (function/const) id counts from the next (first) field.
//Type layout (the position of vtab) can only be controlled by RuntimeLoader. Platform might be allowed
//to specify whether to expand the vtab content (so we don't need a pointer).

/*

----------------------------------------------
Common Header <- Class/base class Ptr
----------------------------------------------
Virtual Table Ptr
	Base virtual function 1
Base Interface A Table Ptr <- Interface A Ptr
	This offset
	Function A1 dest
Base Field A
Base Field B
----------------------------------------------
Interface B Table Ptr <- Interface B Ptr
	This offset
	Function B1 dest
Field C
Field D
----------------------------------------------

*/

class RuntimeLoader
{
	/*
	 * About the loading process:
	 *
	 * Each reference type will undergo the following stages:
	 * 1. LoadTypeInternal. Then move to _loadingRefTypes. Pointer available.
	 * 2. LoadFields. Then move to _postLoadingTypes.
	 * 3. PostLoadType. Then move to _finishedLoadingTypes.
	 * 4. (After all finished.) MoveFinishedObjects. Then move to _loadedTypes.
	 *
	 * Each value type will undergo the following stages:
	 * 1. LoadTypeInternal -> LoadFields.
	 *    Then move to _postLoadingTypes. Pointer available.
	 * 2. PostLoadType. Then move to _finishedLoadingTypes.
	 * 3. (After all finished.) MoveFinishedObjects. Then move to _loadedTypes.
	 *
	 * Each function will undergo the following stages:
	 * 1. LoadFunctionInternal. Then move to _loadingFunctions. Pointer available.
	 * 2. PostLoadFunction. Then move to _finishedLoadingFunctions.
	 * 3. (After all finished.) MoveFinishedObjects. Then move to _loadedFunctions.
	 *
	 * OnXXXLoaded virtual functions are called within MoveFinishedObjects to allow
	 * subclasses to do custom registration work. After all objects are processed,
	 * all objects are moved to loaded list. If any function call fails by throwing
	 * an InternalException, no object will be moved to loaded list and the API fails.
	 *
	 */

	/**
	 * Changes to the above loading procedure (constrains)
	 *
	 * Requirements:
	 * 1. Constrain check should happen before loading fields.
	 * 2. Because of possible recursive constrain, we must check
	 *    after creating the RuntimeType pointer.
	 *    A have alias A1=int, requires B::B1, and B requires A::A1.
	 *    When loading A, we check A->B::B1->A::A1.
	 * 3. We must detect infinite recursive constrain.
	 *    A has A1=B::B1, and B has B1=A::A1.
	 *    When loading A, we check A->B::B1->A::A1->B::B1->...
	 *    Note that we don't have SFINAE. This is an error.
	 * 4. We need a back reference from type/function list to
	 *    constrain list in order to quickly find the constrain to
	 *    check when that entry is referred by another type.
	 *
	 * Changes on loading procedure:
	 * 1. All constrains are 'instantiated' before checking. An
	 *    instance of a constrain contains a list of type and a
	 *    list of function, similar to a GenericDeclaration. The
	 *    process of checking a constrain is to calculate these
	 *    two lists.
	 * 2. Constrains requiring a type or a typa alias, no matter
	 *    as a template or as a instantiated type, to exist, simply
	 *    points to the entry in type list.
	 * 3. When constrain is checked, all entries of the type/function
	 *    list that are referenced by the constrain are loaded.
	 *    Other entries are nullptr and to be loaded later.
	 * 4. When referencing an type/function entry in another loading
	 *    type while checking constrain for one type, and if that 
	 *    type has not finished its constrain check, it forms a 
	 *    recursive reference.
	 * 5. Recursive reference is acceptable if there is no infinite
	 *    loop. This can be detected by setting the entry of 
	 *    _referencedTypes/Functions to a special value before
	 *    performing the actual loading task.
	 * 6. The _loadingTypes stack plus the method in 5. can prevent
	 *    infinite recursion in constrain check.
	 * 7. When post-loading a type, only the not-null entries in
	 *    the type/function list are calculated.
	 */

protected:
	//Exception thrown internally within RuntimeLoader (and subclasses).
	class RuntimeLoaderException : public std::runtime_error
	{
	public:
		RuntimeLoaderException(const std::string& msg)
			: std::runtime_error(msg)
		{
		}
	};

	struct SubtypeLoadingArguments
	{
		RuntimeType* Parent;
		std::string Name;
		std::vector<RuntimeType*> Arguments;

		bool operator == (const SubtypeLoadingArguments &b) const
		{
			return Parent == b.Parent && Name == b.Name && Arguments == b.Arguments;
		}

		bool operator != (const SubtypeLoadingArguments &b) const
		{
			return !(*this == b);
		}
	};

public:
	RuntimeLoader(AssemblyList assemblies, std::size_t ptrSize = sizeof(void*),
		std::size_t itabPtrSize = sizeof(void*), std::size_t loadingLimit = 256)
		: _assemblies(std::move(assemblies)), _ptrSize(ptrSize),
		_itabPtrSize(itabPtrSize), _loadingLimit(loadingLimit)
	{
		FindInternalTypeId();
	}

	virtual ~RuntimeLoader() {}

public:
	RuntimeType* GetType(const LoadingArguments& args, std::string& err)
	{
		std::lock_guard<Spinlock> lock(_loaderLock);
		for (auto& t : _loadedTypes)
		{
			if (t && t->Args == args)
			{
				return t.get();
			}
		}
		return LoadTypeNoLock(args, err);
	}

	RuntimeFunction* GetFunction(const LoadingArguments& args, std::string& err)
	{
		std::lock_guard<Spinlock> lock(_loaderLock);
		for (auto& f : _loadedFunctions)
		{
			if (f->Args == args)
			{
				return f.get();
			}
		}
		return LoadFunctionNoLock(args, err);
	}

	RuntimeType* AddNativeType(const std::string& assemblyName, const std::string& name,
		std::size_t size, std::size_t alignment, std::string& err)
	{
		std::lock_guard<Spinlock> lock(_loaderLock);
		try
		{
			auto id = FindNativeIdThrow(FindAssemblyThrow(assemblyName)->NativeTypes, name);
			return AddNativeTypeInternal(assemblyName, id, size, alignment);
		}
		catch (std::exception& ex)
		{
			err = ex.what();
		}
		catch (...)
		{
			err = "Unknown exception in adding native type";
		}
		return nullptr;
	}

public:
	RuntimeType* GetTypeById(std::uint32_t id)
	{
		std::lock_guard<Spinlock> lock(_loaderLock);
		if (id >= _loadedTypes.size())
		{
			return nullptr;
		}
		return _loadedTypes[id].get();
	}

	RuntimeFunction* GetFunctionById(std::uint32_t id)
	{
		std::lock_guard<Spinlock> lock(_loaderLock);
		if (id > _loadedFunctions.size())
		{
			return nullptr;
		}
		return _loadedFunctions[id].get();
	}

	bool FindExportType(const AssemblyImport& args, LoadingArguments& result)
	{
		auto a = FindAssemblyThrow(args.AssemblyName);
		for (auto& e : a->ExportTypes)
		{
			if (e.ExportName == args.ImportName)
			{
				if (e.InternalId >= a->Types.size())
				{
					auto importId = e.InternalId - a->Types.size();
					if (importId >= a->ImportTypes.size())
					{
						return false;
					}
					return FindExportType(a->ImportTypes[importId], result);
				}
				if (args.GenericParameters != SIZE_MAX &&
					a->Types[e.InternalId].Generic.ParameterCount != args.GenericParameters)
				{
					return false;
				}
				result.Assembly = args.AssemblyName;
				result.Id = e.InternalId;
				return true;
			}
		}
		return false;
	}

	bool FindExportFunction(const AssemblyImport& args, LoadingArguments& result)
	{
		auto a = FindAssemblyThrow(args.AssemblyName);
		for (auto& e : a->ExportFunctions)
		{
			if (e.ExportName == args.ImportName)
			{
				if (e.InternalId >= a->Functions.size())
				{
					auto importId = e.InternalId - a->Functions.size();
					if (importId >= a->ImportFunctions.size())
					{
						return false;
					}
					return FindExportFunction(a->ImportFunctions[importId], result);
				}
				if (args.GenericParameters != SIZE_MAX &&
					a->Functions[e.InternalId].Generic.ParameterCount != args.GenericParameters)
				{
					return false;
				}
				result.Assembly = args.AssemblyName;
				result.Id = e.InternalId;
				return true;
			}
		}
		return false;
	}

	std::uint32_t FindExportConstant(const std::string& assemblyName, const std::string& n)
	{
		auto a = FindAssemblyThrow(assemblyName);
		for (auto& e : a->ExportConstants)
		{
			if (e.ExportName == n) return (std::uint32_t)e.InternalId;
		}
		throw RuntimeLoaderException("Constant export not found");
	}

	std::size_t GetPointerSize()
	{
		return _ptrSize;
	}

private:
	RuntimeType* LoadTypeNoLock(const LoadingArguments& args, std::string& err)
	{
		ClearLoadingLists();
		RuntimeType* ret = nullptr;
		try
		{
			auto ret2 = LoadTypeInternal(args, false);
			ProcessLoadingLists();
			MoveFinishedObjects();
			ret = ret2;
		}
		catch (std::exception& ex)
		{
			err = ex.what();
		}
		catch (...)
		{
			err = "Unknown exception in loading type";
		}
		ClearLoadingLists();
		return ret;
	}

	RuntimeFunction* LoadFunctionNoLock(const LoadingArguments& args, std::string& err)
	{
		ClearLoadingLists();
		RuntimeFunction* ret = nullptr;
		try
		{
			auto ret2 = LoadFunctionInternal(args);
			ProcessLoadingLists();
			MoveFinishedObjects();
			ret = ret2;
		}
		catch (std::exception& ex)
		{
			err = ex.what();
		}
		catch (...)
		{
			err = "Unknown exception in loading function";
		}
		ClearLoadingLists();
		return ret;
	}

	std::uint32_t LoadImportConstant(Assembly* a, std::size_t index)
	{
		if (index >= a->ImportConstants.size())
		{
			throw RuntimeLoaderException("Invalid constant import reference");
		}
		auto info = a->ImportConstants[index];
		if (info.GenericParameters != 0)
		{
			throw RuntimeLoaderException("Invalid constant import");
		}
		return FindExportConstant(info.AssemblyName, info.ImportName);
	}

#if /* Loading stages */ 1

private:
	RuntimeType* AddNativeTypeInternal(const std::string& assemblyName, std::size_t id,
		std::size_t size, std::size_t alignment)
	{
		auto a = FindAssemblyThrow(assemblyName);
		auto& type = a->Types[id];
		if (type.Generic.ParameterCount)
		{
			throw RuntimeLoaderException("Native type cannot be generic");
		}
		if (type.GCMode != TSM_VALUE)
		{
			throw RuntimeLoaderException("Internal type can only be value type");
		}
		if (type.Finalizer >= type.Generic.Functions.size())
		{
			throw RuntimeLoaderException("Invalid function reference");
		}
		if ((type.Generic.Functions[type.Finalizer].Type & REF_REFTYPES) != REF_EMPTY)
		{
			throw RuntimeLoaderException("Internal type cannot have finalizer");
		}
		if (type.Initializer >= type.Generic.Functions.size())
		{
			throw RuntimeLoaderException("Invalid function reference");
		}
		if ((type.Generic.Functions[type.Initializer].Type & REF_REFTYPES) != REF_EMPTY)
		{
			throw RuntimeLoaderException("Internal type cannot have initializer");
		}
		auto rt = std::make_unique<RuntimeType>();
		rt->Parent = this;
		rt->TypeId = _nextTypeId++;
		rt->Args.Assembly = assemblyName;
		rt->Args.Id = id;
		rt->Storage = TSM_VALUE;
		rt->Size = size;
		rt->Alignment = alignment;
		rt->Initializer = nullptr;
		rt->Finalizer = nullptr;
		rt->VirtualTableType = nullptr;

		auto ret = rt.get();
		FinalCheckType(ret);
		OnTypeLoaded(ret);
		AddLoadedType(std::move(rt));
		return ret;
	}

	void ClearLoadingLists()
	{
		_loadingTypes.clear();
		_loadingFunctions.clear();
		_loadingRefTypes.clear();
		_postLoadingTypes.clear();
		_finishedLoadingTypes.clear();
		_finishedLoadingFunctions.clear();
	}

	void MoveFinishedObjects()
	{
		for (auto& t : _finishedLoadingTypes)
		{
			FinalCheckType(t.get());
			OnTypeLoaded(t.get());
		}
		for (auto& f : _finishedLoadingFunctions)
		{
			FinalCheckFunction(f.get());
			OnFunctionLoaded(f.get());
		}
		while (_finishedLoadingTypes.size() > 0)
		{
			auto t = std::move(_finishedLoadingTypes.front());
			AddLoadedType(std::move(t));
			_finishedLoadingTypes.pop_front();
		}
		while (_finishedLoadingFunctions.size() > 0)
		{
			auto f = std::move(_finishedLoadingFunctions.front());
			AddLoadedFunction(std::move(f));
			_finishedLoadingFunctions.pop_front();
		}
	}

	void ProcessLoadingLists()
	{
		assert(_loadingTypes.size() == 0);

		while (true)
		{
			if (_loadingRefTypes.size())
			{
				auto t = std::move(_loadingRefTypes.front());
				_loadingRefTypes.pop_front();
				LoadFields(std::move(t), nullptr);
				assert(_loadingTypes.size() == 0);
				continue;
			}
			if (_postLoadingTypes.size())
			{
				auto t = std::move(_postLoadingTypes.front());
				_postLoadingTypes.pop_front();
				PostLoadType(std::move(t));
				assert(_loadingTypes.size() == 0);
				continue;
			}
			if (_loadingFunctions.size())
			{
				auto t = std::move(_loadingFunctions.front());
				_loadingFunctions.pop_front();
				PostLoadFunction(std::move(t));
				assert(_loadingTypes.size() == 0);
				continue;
			}
			break;
		}
	}

	bool CheckGenericArguments(GenericDeclaration& g, const LoadingArguments& args)
	{
		if (g.ParameterCount != args.Arguments.size())
		{
			return false;
		}
		if (std::any_of(args.Arguments.begin(), args.Arguments.end(),
			[](RuntimeType* t) { return t == nullptr; }))
		{
			return false;
		}
		return CheckConstrains(args.Assembly, &g, args.Arguments);
	}

	RuntimeType* LoadTypeInternal(const LoadingArguments& args, bool skipArgumentCheck)
	{
		for (auto& t : _loadedTypes)
		{
			if (t && t->Args == args)
			{
				return t.get();
			}
		}
		for (auto& t : _finishedLoadingTypes)
		{
			if (t->Args == args)
			{
				return t.get();
			}
		}
		for (auto& t : _postLoadingTypes)
		{
			if (t->Args == args)
			{
				return t.get();
			}
		}
		for (auto& t : _loadingRefTypes)
		{
			if (t->Args == args)
			{
				return t.get();
			}
		}
		for (auto t : _loadingTypes)
		{
			if (t->Args == args)
			{
				return t;
			}
		}

		auto typeTemplate = FindTypeTemplate(args);
		if (!skipArgumentCheck && !CheckGenericArguments(typeTemplate->Generic, args))
		{
			throw RuntimeLoaderException("Invalid generic arguments");
		}

		if (typeTemplate->Generic.Fields.size() != 0)
		{
			throw RuntimeLoaderException("Type template cannot contain field reference");
		}

		if (args.Assembly == "Core" && args.Id == _boxTypeId)
		{
			if (args.Arguments.size() != 1 ||
				args.Arguments[0]->Storage != TSM_VALUE)
			{
				throw RuntimeLoaderException("Box type can only take value type as argument");
			}
		}

		auto t = std::make_unique<RuntimeType>();
		t->Parent = this;
		t->Args = args;
		t->TypeId = _nextTypeId++;
		t->Storage = typeTemplate->GCMode;
		t->PointerType = nullptr;

		if (typeTemplate->GCMode == TSM_REFERENCE || typeTemplate->GCMode == TSM_INTERFACE)
		{
			RuntimeType* ret = t.get();
			_loadingRefTypes.push_back(std::move(t));
			return ret;
		}
		else
		{
			return LoadFields(std::move(t), typeTemplate);
		}
	}

	RuntimeFunction* LoadFunctionInternal(const LoadingArguments& args)
	{
		for (auto& ff : _loadedFunctions)
		{
			if (ff && ff->Args == args)
			{
				return ff.get();
			}
		}
		for (auto& ff : _finishedLoadingFunctions)
		{
			if (ff->Args == args)
			{
				return ff.get();
			}
		}
		for (auto& ff : _loadingFunctions)
		{
			if (ff->Args == args)
			{
				return ff.get();
			}
		}

		auto funcTemplate = FindFunctionTemplate(args.Assembly, args.Id);
		CheckGenericArguments(funcTemplate->Generic, args);

		auto f = std::make_unique<RuntimeFunction>();
		auto ret = f.get();
		_loadingFunctions.push_back(std::move(f));
		ret->Args = args;
		ret->Parent = this;
		ret->FunctionId = _nextFunctionId++;
		ret->Code = GetCode(args.Assembly, args.Id);
		return ret;
	}

	bool TypeIsInLoading(RuntimeType* t)
	{
		for (auto i : _loadingTypes)
		{
			if (i == t) return true;
		}
		return false;
	}

	RuntimeType* LoadSubtype(const SubtypeLoadingArguments& args)
	{
		for (auto& t : _loadingSubtypes)
		{
			if (t == args)
			{
				throw RuntimeLoaderException("Cyclic reference in subtype");
			}
		}
		_loadingSubtypes.push_back(args);
		if (_loadingTypes.size() + _loadingFunctions.size() +
			_loadingSubtypes.size() > _loadingLimit)
		{
			throw RuntimeLoaderException("Loading object limit exceeded.");
		}

		auto tt = FindTypeTemplate(args.Parent->Args);
		std::size_t id = SIZE_MAX;
		for (auto& n : tt->PublicSubTypes)
		{
			if (n.Name == args.Name)
			{
				id = n.Id;
				break;
			}
		}
		if (id == SIZE_MAX)
		{
			throw RuntimeLoaderException("Subtype name not found");
		}
		
		LoadingRefArguments la(args.Parent, tt->Generic, args.Arguments);
		auto ret = LoadRefType(la, id);

		assert(_loadingSubtypes.back() == args);
		_loadingSubtypes.pop_back();

		return ret;
	}

	RuntimeType* LoadFields(std::unique_ptr<RuntimeType> type, Type* typeTemplate)
	{
		for (auto t : _loadingTypes)
		{
			assert(!(t->Args == type->Args));
		}
		_loadingTypes.push_back(type.get());
		if (_loadingTypes.size() + _loadingFunctions.size() +
			_loadingSubtypes.size() > _loadingLimit)
		{
			throw RuntimeLoaderException("Loading object limit exceeded.");
		}

		Type* tt = typeTemplate;
		if (tt == nullptr)
		{
			tt = FindTypeTemplate(type->Args);
		}

		if (type->Storage == TSM_INTERFACE)
		{
			if (tt->Fields.size() != 0)
			{
				throw RuntimeLoaderException("Interface cannot have fields");
			}
		}

		//Virtual table
		auto vtabType = LoadRefType({ type.get(), tt->Generic }, tt->Base.VirtualTableType);
		if (vtabType != nullptr)
		{
			if (vtabType->Storage != TSM_GLOBAL)
			{
				throw RuntimeLoaderException("Vtab type must be global storage");
			}
			if (type->Storage == TSM_GLOBAL || type->Storage == TSM_VALUE)
			{
				throw RuntimeLoaderException("Global and value type cannot have vtab");
			}

			type->VirtualTableType = vtabType;
		}
		else
		{
			if (type->Storage == TSM_INTERFACE)
			{
				throw RuntimeLoaderException("Interface must have vtab");
			}
		}

		//Base type
		auto baseType = LoadRefType({ type.get(), tt->Generic }, tt->Base.InheritedType);
		if (baseType != nullptr)
		{
			if (type->Storage == TSM_GLOBAL)
			{
				throw RuntimeLoaderException("Global type cannot have base type");
			}
			else if (type->Storage == TSM_INTERFACE)
			{
				throw RuntimeLoaderException("Interface cannot have base type");
			}
			else
			{
				if (type->Storage != baseType->Storage)
				{
					throw RuntimeLoaderException("Base type storage must be same as the derived type");
				}
			}
			type->BaseType = baseType;
		}
		CheckVirtualTable(baseType, vtabType);

		std::size_t offset = 0, totalAlignment = 1;

		//Fields
		std::vector<RuntimeType*> fields;
		for (auto typeId : tt->Fields)
		{
			auto fieldType = LoadRefType({ type.get(), tt->Generic }, typeId);
			if (fieldType == nullptr)
			{
				//Only goes here if REF_EMPTY is specified.
				throw RuntimeLoaderException("Invalid field type");
			}
			if (fieldType->Storage == TSM_VALUE && fieldType->Alignment == 0)
			{
				assert(TypeIsInLoading(fieldType));
				throw RuntimeLoaderException("Cyclic type dependence");
			}
			fields.push_back(fieldType);
		}

		for (std::size_t i = 0; i < fields.size(); ++i)
		{
			auto ftype = fields[i];
			std::size_t len, alignment;
			switch (ftype->Storage)
			{
			case TSM_REFERENCE:
			case TSM_INTERFACE:
				len = alignment = _ptrSize;
				break;
			case TSM_VALUE:
				len = ftype->Size;
				alignment = ftype->Alignment;
				break;
			default:
				throw RuntimeLoaderException("Invalid field type");
			}
			offset = (offset + alignment - 1) / alignment * alignment;
			totalAlignment = alignment > totalAlignment ? alignment : totalAlignment;
			type->Fields.push_back({ ftype, offset, len });
			offset += len;
		}
		type->Size = offset;
		type->Alignment = totalAlignment;

		auto ret = type.get();
		_postLoadingTypes.emplace_back(std::move(type));

		assert(_loadingTypes.back() == ret);
		_loadingTypes.pop_back();

		return ret;
	}

	void PostLoadType(std::unique_ptr<RuntimeType> type)
	{
		auto typeTemplate = FindTypeTemplate(type->Args);

		for (std::size_t i = 0; i < typeTemplate->Generic.Types.size(); ++i)
		{
			if (typeTemplate->Generic.Types[i].Type & REF_FORCELOAD)
			{
				SetValueInList(type->References.Types, i, LoadRefType({ type.get(), typeTemplate->Generic }, i));
			}
		}
		for (std::size_t i = 0; i < typeTemplate->Generic.Functions.size(); ++i)
		{
			if (typeTemplate->Generic.Functions[i].Type & REF_FORCELOAD)
			{
				SetValueInList(type->References.Functions, i, LoadRefFunction({ type.get(), typeTemplate->Generic }, i));
			}
		}

		if (type->Storage == TSM_GLOBAL)
		{
			if (typeTemplate->Interfaces.size() != 0)
			{
				throw RuntimeLoaderException("Global and value type cannot have interfaces");
			}
		}

		if (type->Args.Assembly == "Core" && type->Args.Id == _boxTypeId)
		{
			if (type->Args.Arguments[0]->Storage == TSM_VALUE)
			{
				LoadInterfaces(type.get(), type->Args.Arguments[0], nullptr);
			}
		}
		else if (type->Storage == TSM_INTERFACE || type->Storage == TSM_REFERENCE)
		{
			LoadInterfaces(type.get(), type.get(), typeTemplate);
		}

		type->Initializer = LoadRefFunction({ type.get(), typeTemplate->Generic }, typeTemplate->Initializer);
		type->Finalizer = LoadRefFunction({ type.get(), typeTemplate->Generic }, typeTemplate->Finalizer);
		if (type->Storage != TSM_GLOBAL)
		{
			if (type->Initializer != nullptr)
			{
				throw RuntimeLoaderException("Only global type can have initializer");
			}
		}
		if (type->Storage != TSM_REFERENCE)
		{
			if (type->Finalizer != nullptr)
			{
				throw RuntimeLoaderException("Only reference type can have finalizer");
			}
		}
		_finishedLoadingTypes.emplace_back(std::move(type));
	}

	void PostLoadFunction(std::unique_ptr<RuntimeFunction> func)
	{
		//TODO Optimize loading. Directly find the cloned func/type.
		auto funcTemplate = FindFunctionTemplate(func->Args.Assembly, func->Args.Id);
		for (std::size_t i = 0; i < funcTemplate->Generic.Types.size(); ++i)
		{
			if (funcTemplate->Generic.Types[i].Type & REF_FORCELOAD)
			{
				SetValueInList(func->References.Types, i,
					LoadRefType({ func.get(), funcTemplate->Generic }, i));
			}
		}
		for (std::size_t i = 0; i < funcTemplate->Generic.Functions.size(); ++i)
		{
			if (funcTemplate->Generic.Functions[i].Type & REF_FORCELOAD)
			{
				SetValueInList(func->References.Functions, i,
					LoadRefFunction({ func.get(), funcTemplate->Generic }, i));
			}
		}
		auto assembly = FindAssemblyThrow(func->Args.Assembly);
		for (std::size_t i = 0; i < funcTemplate->Generic.Fields.size(); ++i)
		{
			func->ReferencedFields.push_back(LoadImportConstant(assembly, funcTemplate->Generic.Fields[i]));
		}
		func->ReturnValue = func->References.Types[funcTemplate->ReturnValue.TypeId];
		for (std::size_t i = 0; i < funcTemplate->Parameters.size(); ++i)
		{
			func->Parameters.push_back(func->References.Types[funcTemplate->Parameters[i].TypeId]);
		}
		auto ptr = func.get();
		_finishedLoadingFunctions.emplace_back(std::move(func));
	}

	void FinalCheckType(RuntimeType* type)
	{
		if (type->Args.Assembly == "Core" && type->Args.Id == _pointerTypeId)
		{
			assert(type->Storage == TSM_VALUE);
			assert(type->Args.Arguments.size() == 1);
			auto elementType = type->Args.Arguments[0];
			assert(elementType->PointerType == nullptr);
			elementType->PointerType = type;
		}
		//TODO check box type?
		if (type->Initializer != nullptr)
		{
			if (type->Initializer->ReturnValue != nullptr ||
				type->Initializer->Parameters.size() != 0)
			{
				throw RuntimeLoaderException("Invalid initializer");
			}
		}
		if (type->Finalizer != nullptr)
		{
			if (type->Finalizer->ReturnValue != nullptr ||
				type->Finalizer->Parameters.size() != 1)
			{
				throw RuntimeLoaderException("Invalid finalizer");
			}
			if (type->Finalizer->Parameters[0] != type)
			{
				throw RuntimeLoaderException("Invalid finalizer");
			}
		}
	}

	void FinalCheckFunction(RuntimeFunction* func)
	{
	}

	void LoadInterfaces(RuntimeType* dest, RuntimeType* src, Type* srcTemplate)
	{
		if (srcTemplate == nullptr)
		{
			srcTemplate = FindTypeTemplate(src->Args);
		}
		for (auto& i : srcTemplate->Interfaces)
		{
			RuntimeType::InterfaceInfo ii = {};

			auto vtabType = LoadRefType({ src, srcTemplate->Generic }, i.VirtualTableType);
			if (vtabType == nullptr && src->Storage != TSM_INTERFACE)
			{
				throw RuntimeLoaderException("Vtab type not specified for interface");
			}
			if (vtabType != nullptr)
			{
				if (vtabType->Storage != TSM_GLOBAL)
				{
					throw RuntimeLoaderException("Vtab type must be global storage");
				}
				ii.VirtualTable = vtabType;
			}

			auto baseType = LoadRefType({ src, srcTemplate->Generic }, i.InheritedType);
			if (baseType == nullptr)
			{
				throw RuntimeLoaderException("Interface type not specified");
			}
			if (baseType->Storage != TSM_INTERFACE)
			{
				throw RuntimeLoaderException("Interface must be interface storage");
			}
			ii.Type = baseType;

			CheckVirtualTable(ii.Type, ii.VirtualTable);
			dest->Interfaces.push_back(ii);
		}
	}

	void CheckVirtualTable(RuntimeType* baseType, RuntimeType* vtabType)
	{
		if (baseType && baseType->VirtualTableType && vtabType == nullptr)
		{
			throw RuntimeLoaderException("Vtab not matching base type");
		}
		if (vtabType && baseType && baseType->VirtualTableType)
		{
			auto tbase = baseType->VirtualTableType;
			if (tbase->Fields.size() > vtabType->Fields.size())
			{
				throw RuntimeLoaderException("Vtab not matching base type");
			}
			for (std::size_t i = 0; i < tbase->Fields.size(); ++i)
			{
				auto& fbase = tbase->Fields[i];
				auto& fderived = vtabType->Fields[i];
				if (fbase.Type != fderived.Type)
				{
					throw RuntimeLoaderException("Vtab not matching base type");
				}
				assert(fbase.Offset == fderived.Offset);
				assert(fbase.Length == fderived.Length);
			}
		}
	}

#endif

	template <typename T>
	static void SetValueInList(std::vector<T>& v, std::size_t n, T&& val)
	{
		while (v.size() < n)
		{
			v.push_back({});
		}
		if (v.size() == n)
		{
			v.push_back(std::forward<T>(val));
		}
		else
		{
			assert(v[n] == T());
			v[n] = std::forward<T>(val);
		}
	}

private:
	void FindInternalTypeId()
	{
		_pointerTypeId = _boxTypeId = SIZE_MAX;
		if (auto a = FindAssemblyNoThrow("Core"))
		{
			for (auto& e : a->ExportTypes)
			{
				if (e.ExportName == "Core.Pointer")
				{
					if (e.InternalId >= a->Types.size() ||
						!CheckPointerTypeTemplate(&a->Types[e.InternalId]) ||
						_pointerTypeId != SIZE_MAX)
					{
						//This is actually an error, but we don't want to throw in ctor.
						//Let's wait for the type loading to fail.
						return;
					}
					_pointerTypeId = e.InternalId;
				}
				else if (e.ExportName == "Core.Box")
				{
					if (e.InternalId >= a->Types.size() ||
						!CheckBoxTypeTemplate(&a->Types[e.InternalId]) ||
						_boxTypeId != SIZE_MAX)
					{
						return;
					}
					_boxTypeId = e.InternalId;
				}
			}
		}
	}

	bool CheckPointerTypeTemplate(Type* t)
	{
		if (t->Generic.ParameterCount != 1) return false;
		if (t->GCMode != TSM_VALUE) return false;
		return true;
	}

	bool CheckBoxTypeTemplate(Type* t)
	{
		if (t->Generic.ParameterCount != 1) return false;
		if (t->GCMode != TSM_REFERENCE) return false;
		return true;
	}

public:
	RuntimeType* LoadPointerType(RuntimeType* t, std::string& err)
	{
		assert(t->PointerType == nullptr);
		LoadingArguments args;
		args.Assembly = "Core";
		args.Id = _pointerTypeId;
		args.Arguments.push_back(t);
		return GetType(args, err);
	}

	//TODO maybe cache result in RuntimeType
	bool IsPointerType(RuntimeType* t)
	{
		return t->Args.Assembly == "Core" && t->Args.Id == _pointerTypeId;
	}

protected:
	virtual void OnTypeLoaded(RuntimeType* type)
	{
	}

	virtual void OnFunctionLoaded(RuntimeFunction* func)
	{
	}

#if /* Load reference list */ 1

private:
	struct LoadingRefArguments
	{
		const GenericDeclaration& Declaration;
		const LoadingArguments& Arguments;
		RuntimeType* SelfType;
		const std::vector<RuntimeType*>* AdditionalArguments;

		LoadingRefArguments(RuntimeType* type, const GenericDeclaration& g)
			: Declaration(g), Arguments(type->Args), SelfType(type), AdditionalArguments(nullptr)
		{
		}

		LoadingRefArguments(RuntimeFunction* func, const GenericDeclaration& g)
			: Declaration(g), Arguments(func->Args), SelfType(nullptr), AdditionalArguments(nullptr)
		{
		}

		LoadingRefArguments(RuntimeType* type, const GenericDeclaration& g, const std::vector<RuntimeType*>& aa)
			: Declaration(g), Arguments(type->Args), SelfType(type), AdditionalArguments(&aa)
		{
		}
	};

	RuntimeType* LoadRefType(LoadingRefArguments lg, std::size_t typeId)
	{
		if (typeId >= lg.Declaration.Types.size())
		{
			throw RuntimeLoaderException("Invalid type reference");
		}
		auto type = lg.Declaration.Types[typeId];
		LoadingArguments la;
	loadClone:
		switch (type.Type & REF_REFTYPES)
		{
		case REF_EMPTY:
			return nullptr;
		case REF_CLONE:
			if (type.Index >= lg.Declaration.Types.size())
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			typeId = type.Index;
			type = lg.Declaration.Types[type.Index];
			goto loadClone;
		case REF_ASSEMBLY:
			la.Assembly = lg.Arguments.Assembly;
			la.Id = type.Index;
			LoadRefTypeArgList(lg, typeId, la);
			return LoadTypeInternal(la, false);
		case REF_IMPORT:
		{
			auto a = FindAssemblyThrow(lg.Arguments.Assembly);
			if (type.Index >= a->ImportTypes.size())
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			auto i = a->ImportTypes[type.Index];
			if (!FindExportType(i, la))
			{
				throw RuntimeLoaderException("Import type not found");
			}
			LoadRefTypeArgList(lg, typeId, la);
			if (la.Arguments.size() != i.GenericParameters)
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			return LoadTypeInternal(la, false);
		}
		case REF_ARGUMENT:
			if (type.Index >= lg.Arguments.Arguments.size())
			{
				auto aaid = type.Index - lg.Arguments.Arguments.size();
				if (lg.AdditionalArguments == nullptr || aaid >= lg.AdditionalArguments->size())
				{
					throw RuntimeLoaderException("Invalid type reference");
				}
				return (*lg.AdditionalArguments)[aaid];
			}
			return lg.Arguments.Arguments[type.Index];
		case REF_SELF:
			if (lg.SelfType == nullptr)
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			return lg.SelfType;
		case REF_SUBTYPE:
		{
			auto name = lg.Declaration.SubtypeNames[type.Index];
			auto parent = LoadRefType(lg, typeId + 1);
			LoadRefTypeArgList(lg, typeId + 1, la);
			return LoadSubtype({ parent, name, la.Arguments });
		}
		case REF_CLONETYPE:
		default:
			throw RuntimeLoaderException("Invalid type reference");
		}
	}

	void LoadRefTypeArgList(LoadingRefArguments lg, std::size_t index, LoadingArguments& la)
	{
		for (std::size_t i = index + 1; i < lg.Declaration.Types.size(); ++i)
		{
			if (lg.Declaration.Types[i].Type == REF_EMPTY) break; //Use REF_Empty as the end of arg list
			la.Arguments.push_back(LoadRefType(lg, i));
		}
	}

	RuntimeFunction* LoadRefFunction(LoadingRefArguments lg, std::size_t funcId)
	{
		if (funcId >= lg.Declaration.Functions.size())
		{
			throw RuntimeLoaderException("Invalid function reference");
		}
		auto func = lg.Declaration.Functions[funcId];
		LoadingArguments la;
	loadClone:
		switch (func.Type & REF_REFTYPES)
		{
		case REF_EMPTY:
			return nullptr;
		case REF_CLONE:
			if (func.Index >= lg.Declaration.Functions.size())
			{
				throw RuntimeLoaderException("Invalid function reference");
			}
			funcId = func.Index;
			func = lg.Declaration.Functions[func.Index];
			goto loadClone;
		case REF_ASSEMBLY:
			la.Assembly = lg.Arguments.Assembly;
			la.Id = func.Index;
			LoadRefFuncArgList(lg, funcId, la);
			return LoadFunctionInternal(la);
		case REF_IMPORT:
		{
			auto a = FindAssemblyThrow(lg.Arguments.Assembly);
			if (func.Index >= a->ImportFunctions.size())
			{
				throw RuntimeLoaderException("Invalid function reference");
			}
			auto i = a->ImportFunctions[func.Index];
			if (!FindExportFunction(i, la))
			{
				throw RuntimeLoaderException("Import function not found");
			}
			LoadRefFuncArgList(lg, funcId, la);
			if (la.Arguments.size() != i.GenericParameters)
			{
				throw RuntimeLoaderException("Invalid function reference");
			}
			return LoadFunctionInternal(la);
		}
		case REF_CLONETYPE:
			return nullptr;
		case REF_ARGUMENT:
		case REF_SELF:
		case REF_SUBTYPE:
		default:
			throw RuntimeLoaderException("Invalid function reference");
		}
	}

	void LoadRefFuncArgList(LoadingRefArguments lg, std::size_t index, LoadingArguments& la)
	{
		for (std::size_t i = index + 1; i < lg.Declaration.Functions.size(); ++i)
		{
			if (lg.Declaration.Functions[i].Type == REF_EMPTY) break;
			if (lg.Declaration.Functions[i].Type != REF_CLONETYPE)
			{
				throw RuntimeLoaderException("Invalid generic function argument");
			}
			la.Arguments.push_back(LoadRefType(lg, lg.Declaration.Functions[i].Index));
		}
	}

#endif

#if /* Constrains */ 1

private:
	enum ConstrainTypeType
	{
		CTT_FAIL,
		CTT_ANY,
		CTT_GENERIC,
		CTT_SUBTYPE,
		CTT_RT,
	};

	using TypeRefList = std::vector<DeclarationReference>;

	struct ConstrainUndeterminedTypeSource;
	struct ConstrainUndeterminedTypeRef
	{
		ConstrainUndeterminedTypeSource* Parent;
		std::size_t Index;
	};
	struct ConstrainUndeterminedTypeInfo
	{
		RuntimeType* Determined;
	};
	struct ConstrainUndeterminedTypeSource
	{
		ConstrainUndeterminedTypeSource* Parent = nullptr;
		std::vector<ConstrainUndeterminedTypeInfo> UndeterminedTypes;
		std::size_t TotalSize = 0;
		bool IsDetermined(std::size_t i)
		{
			auto ps = Parent ? Parent->TotalSize : 0;
			if (i >= ps)
			{
				return UndeterminedTypes[i - ps].Determined != nullptr;
			}
			return Parent->IsDetermined(i);
		}
		void Determined(std::size_t i, RuntimeType* t)
		{
			auto ps = Parent ? Parent->TotalSize : 0;
			if (i >= ps)
			{
				UndeterminedTypes[i - ps].Determined = t;
			}
			else
			{
				Parent->Determined(i, t);
			}
		}
	};
	struct ConstrainType
	{
		ConstrainTypeType CType;
		RuntimeType* Determined;
		std::string TypeTemplateAssembly;
		std::size_t TypeTemplateIndex;
		std::string SubtypeName;
		std::vector<ConstrainType> Args;
		ConstrainUndeterminedTypeRef Undetermined;
		bool TryArgumentConstrain;

		bool ContainsUndetermined()
		{
			switch (CType)
			{
			case CTT_RT: return false;
			case CTT_GENERIC:
			case CTT_SUBTYPE:
				for (auto& a : Args)
				{
					if (a.ContainsUndetermined()) return true;
				}
				return false;
			case CTT_ANY:
				return !Undetermined.Parent->IsDetermined(Undetermined.Index);
			default:
				assert(0);
				return false;
			}
		}

		static ConstrainType Fail()
		{
			return { CTT_FAIL };
		}

		static ConstrainType RT(RuntimeType* rt)
		{
			return { CTT_RT, rt };
		}

		static ConstrainType UD(ConstrainUndeterminedTypeSource& src)
		{
			auto id = src.UndeterminedTypes.size() + (src.Parent ? src.Parent->TotalSize : 0);
			src.UndeterminedTypes.push_back({});
			return { CTT_ANY, nullptr, {}, 0, {}, {}, { &src, id } };
		}

		static ConstrainType G(const std::string& a, std::size_t i)
		{
			return { CTT_GENERIC, nullptr, a, i };
		}

		static ConstrainType SUB(const std::string& n)
		{
			return { CTT_SUBTYPE, nullptr, {}, {}, n };
		}

		static ConstrainType Try(ConstrainType&& t)
		{
			auto ret = ConstrainType(std::move(t));
			ret.TryArgumentConstrain = true;
			return ret;
		}
	};
	struct ConstrainCalculationCacheRoot;
	struct ConstrainCalculationCache : ConstrainUndeterminedTypeSource
	{
		ConstrainCalculationCacheRoot* Root;
		ConstrainCalculationCache* Parent;

		std::string SrcAssembly;
		ConstrainType Target;
		std::vector<ConstrainType> Arguments;
		std::vector<std::unique_ptr<ConstrainCalculationCache>> Children;
	};
	struct ConstrainCalculationCacheRoot
	{
		ConstrainCalculationCache Cache;
		std::size_t Size;
	};

	bool CheckConstrains(const std::string& srcAssebly, GenericDeclaration* g,
		const std::vector<RuntimeType*>& args)
	{
		std::vector<ConstrainType> cargs;
		for (auto a : args)
		{
			cargs.push_back(ConstrainType::RT(a));
		}
		return CheckConstrainsInternal(srcAssebly, g, cargs);
	}

	bool CheckConstrainsInternal(const std::string& srcAssebly, GenericDeclaration* g,
		const std::vector<ConstrainType>& args)
	{
		for (auto& constrain : g->Constrains)
		{
			//TODO need a parent? (cache and undetermined src)
			ConstrainCalculationCacheRoot cc;
			auto& cache = cc.Cache;
			cache.Parent = nullptr;
			cache.Root = &cc;
			cache.SrcAssembly = srcAssebly;
			cache.Target = ConstructConstrainArgumentType(cache, constrain, constrain.Target);
			for (auto a : constrain.Arguments)
			{
				cache.Arguments.push_back(ConstructConstrainArgumentType(cache, constrain, a));
			}
			while (ListContainUndetermined(cache.Arguments, cache.Target))
			{
				if (!TryDetermineConstrainArgument(constrain, cache))
				{
					//Cannot determine some of the REF_ANY arguments.
					//Further constrain check is impossible. We return false to indicate
					//the requirements of this constrain is not met.
					return false;
				}
			}
			//All REF_ANY are resolved.
			if (!CheckConstrainDetermined(constrain, cache))
			{
				return false;
			}
			//TODO calculate exportable references
		}
		return true;
	}

	bool ListContainUndetermined(std::vector<ConstrainType>& l, ConstrainType& t)
	{
		for (auto& a : l)
		{
			if (a.ContainsUndetermined()) return true;
		}
		if (t.ContainsUndetermined()) return true;
		return false;
	}

	ConstrainType ConstructConstrainArgumentType(ConstrainCalculationCache& cache, 
		GenericConstrain& constrain, std::size_t i)
	{
		auto& list = constrain.TypeReferences;
		auto& t = list[i];
		switch (t.Type)
		{
		case REF_ANY:
			return ConstrainType::UD(cache);
		case REF_TRY:
			return ConstrainType::Try(ConstructConstrainArgumentType(cache, constrain, t.Index));
		case REF_CLONE:
			return ConstructConstrainArgumentType(cache, constrain, t.Index);
		case REF_ARGUMENT:
			return cache.Arguments[t.Index];
		case REF_ASSEMBLY:
		{
			auto ret = ConstrainType::G(cache.SrcAssembly, t.Index);
			for (std::size_t j = 1; list[i + j].Type != REF_EMPTY; ++j)
			{
				if (i + j == list.size())
				{
					throw RuntimeLoaderException("Invalid type reference");
				}
				ret.Args.push_back(ConstructConstrainArgumentType(cache, constrain, i + j));
			}
			return ret;
		}
		case REF_IMPORT:
		{
			auto assembly = FindAssemblyThrow(cache.SrcAssembly);
			if (t.Index > assembly->ImportTypes.size())
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			LoadingArguments la;
			FindExportType(assembly->ImportTypes[t.Index], la);
			auto ret = ConstrainType::G(la.Assembly, la.Id);
			for (std::size_t j = 1; list[i + j].Type != REF_EMPTY; ++j)
			{
				if (i + j == list.size())
				{
					throw RuntimeLoaderException("Invalid type reference");
				}
				ret.Args.push_back(ConstructConstrainArgumentType(cache, constrain, i + j));
			}
			if (assembly->ImportTypes[t.Index].GenericParameters != ret.Args.size())
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			return ret;
		}
		case REF_SUBTYPE:
		{
			if (t.Index > constrain.SubtypeNames.size())
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			auto ret = ConstrainType::SUB(constrain.SubtypeNames[t.Index]);
			for (std::size_t j = 1; list[i + j].Type != REF_EMPTY; ++j)
			{
				if (i + j == list.size())
				{
					throw RuntimeLoaderException("Invalid type reference");
				}
				ret.Args.push_back(ConstructConstrainArgumentType(cache, constrain, i + j));
			}
			if (ret.Args.size() == 0)
			{
				throw RuntimeLoaderException("Invalid type reference");
			}
			return ret;
		}
		default:
			throw RuntimeLoaderException("Invalid type reference");
		}
	}

	//ret: 1: determined something. 0: no change. -1: impossible (constrain check fails)
	int TryDetermineEqualTypes(ConstrainType& a, ConstrainType& b)
	{
		SimplifyConstrainType(a);
		SimplifyConstrainType(b);
		if (a.CType == CTT_FAIL || b.CType == CTT_FAIL) return -1;
		if (a.CType == CTT_ANY || b.CType == CTT_ANY)
		{
			if (a.CType == CTT_RT)
			{
				b.Undetermined.Parent->Determined(b.Undetermined.Index, a.Determined);
				return 1;
			}
			else if (b.CType == CTT_RT)
			{
				a.Undetermined.Parent->Determined(a.Undetermined.Index, b.Determined);
				return 1;
			}
			else
			{
				return 0;
			}
		}
		if (a.CType == CTT_SUBTYPE || b.CType == CTT_SUBTYPE) return 0;
		if (a.CType == CTT_RT && b.CType == CTT_RT)
		{
			if (a.Determined != b.Determined) return -1;
			return 0;
		}
		if (a.CType == CTT_GENERIC && b.CType == CTT_GENERIC)
		{
			if (a.TypeTemplateAssembly != b.TypeTemplateAssembly ||
				a.TypeTemplateIndex != b.TypeTemplateIndex ||
				a.Args.size() != b.Args.size())
			{
				return -1;
			}
			for (std::size_t i = 0; i < a.Args.size(); ++i)
			{
				int r = TryDetermineEqualTypes(a.Args[i], b.Args[i]);
				if (r != 0) return r;
			}
			return 0;
		}
		else if (a.CType == CTT_RT)
		{
			if (a.Determined->Args.Assembly != b.TypeTemplateAssembly ||
				a.Determined->Args.Id != b.TypeTemplateIndex ||
				a.Determined->Args.Arguments.size() != b.Args.size())
			{
				return -1;
			}
			for (std::size_t i = 0; i < b.Args.size(); ++i)
			{
				ConstrainType ct = ConstrainType::RT(a.Determined->Args.Arguments[i]);
				int r = TryDetermineEqualTypes(b.Args[i], ct);
				if (r != 0) return r;
			}
			return 0;
		}
		else //b.CType == CTT_RT
		{
			if (b.Determined->Args.Assembly != a.TypeTemplateAssembly ||
				b.Determined->Args.Id != a.TypeTemplateIndex ||
				b.Determined->Args.Arguments.size() != a.Args.size())
			{
				return -1;
			}
			for (std::size_t i = 0; i < a.Args.size(); ++i)
			{
				ConstrainType ct = ConstrainType::RT(b.Determined->Args.Arguments[i]);
				int r = TryDetermineEqualTypes(a.Args[i], ct);
				if (r != 0) return r;
			}
			return 0;
		}
	}

	bool TryDetermineConstrainArgument(GenericConstrain& c, ConstrainCalculationCache& args)
	{
		if (args.Target.CType == CTT_RT)
		{
			//Only check member components if the parent (target) has been fully determined.
		}
		//for each clause (subconstrain, field, subtype, function)
		//  for subconstrain, create cache if necessary
		//  try determine something
		return false;
	}

	void SimplifyConstrainType(ConstrainType& t)
	{
		switch (t.CType)
		{
		case CTT_ANY:
		case CTT_RT:
		case CTT_FAIL:
			//Elemental type. Can't simplify.
			return;
		case CTT_GENERIC:
		{
			for (auto& arg : t.Args)
			{
				SimplifyConstrainType(arg);
			}
			LoadingArguments la = { t.TypeTemplateAssembly, t.TypeTemplateIndex };
			for (auto& arg : t.Args)
			{
				//TODO use a separate function (3 uses)
				if (arg.CType != CTT_RT)
				{
					if (arg.CType == CTT_FAIL)
					{
						t = ConstrainType::Fail();
					}
					return;
				}
				assert(arg.Determined);
				la.Arguments.push_back(arg.Determined);
			}
			if (t.TryArgumentConstrain)
			{
				auto tt = FindTypeTemplate(la);
				if (!CheckGenericArguments(tt->Generic, la))
				{
					t = ConstrainType::Fail();
				}
			}
			t = ConstrainType::RT(LoadTypeInternal(la, t.TryArgumentConstrain));
			return;
		}
		case CTT_SUBTYPE:
		{
			for (auto& arg : t.Args)
			{
				SimplifyConstrainType(arg);
			}
			assert(t.Args.size() > 0);
			if (t.Args[0].CType != CTT_RT)
			{
				if (t.Args[0].CType == CTT_FAIL)
				{
					t = ConstrainType::Fail();
				}
				return;
			}
			assert(t.Args[0].Determined);
			SubtypeLoadingArguments la = { t.Args[0].Determined, t.Args[0].SubtypeName };
			for (auto i = t.Args.begin() + 1; i < t.Args.end(); ++i)
			{
				if (i->CType != CTT_RT)
				{
					if (i->CType == CTT_FAIL)
					{
						t = ConstrainType::Fail();
					}
					return;
				}
				assert(i->Determined);
				la.Arguments.push_back(i->Determined);
			}
			//LoadSubtype is too complicated to separate the constrain check.
			//We have to use a try block.
			if (t.TryArgumentConstrain)
			{
				try
				{
					t = ConstrainType::RT(LoadSubtype(la));
					return;
				}
				catch (...)
				{
					//TODO make sure it's really caused by type constrain checking.
					t = ConstrainType::Fail();
					return;
				}
			}
			else
			{
				t = ConstrainType::RT(LoadSubtype(la));
				return;
			}
		}
		default:
			break;
		}
	}

	bool CheckConstrainDetermined(GenericConstrain& c, ConstrainCalculationCache& cache)
	{
		switch (c.Type)
		{
		case CONSTRAIN_EXIST:
			if (cache.Arguments.size() != 0)
			{
				throw RuntimeLoaderException("Invalid constrain CONSTRAIN_EXIST");
			}
			SimplifyConstrainType(cache.Target);
			if (cache.Target.CType != CTT_RT)
			{
				assert(cache.Target.CType == CTT_FAIL);
				return false;
			}
			assert(cache.Target.Determined);
			return true;
		case CONSTRAIN_SAME:
			if (cache.Arguments.size() != 1)
			{
				throw RuntimeLoaderException("Invalid constrain CONSTRAIN_EXIST");
			}
			SimplifyConstrainType(cache.Target);
			SimplifyConstrainType(cache.Arguments[0]);
			if (cache.Target.CType != CTT_RT)
			{
				assert(cache.Target.CType == CTT_FAIL);
				return false;
			}
			if (cache.Arguments[0].CType != CTT_RT)
			{
				assert(cache.Arguments[0].CType == CTT_FAIL);
				return false;
			}
			assert(cache.Target.Determined);
			assert(cache.Arguments[0].Determined);
			if (cache.Target.Determined != cache.Arguments[0].Determined)
			{
				return false;
			}
			return true;
		//TODO other constrains
		}
		return false;
	}

#endif

#if /* Helpers */ 1 

protected:
	Assembly* FindAssemblyNoThrow(const std::string& name)
	{
		for (auto& a : _assemblies.Assemblies)
		{
			if (a.AssemblyName == name)
			{
				return &a;
			}
		}
		return nullptr;
	}

	Assembly* FindAssemblyThrow(const std::string& name)
	{
		auto ret = FindAssemblyNoThrow(name);
		if (ret == nullptr)
		{
			throw RuntimeLoaderException("Referenced assembly not found");
		}
		return ret;
	}

	std::size_t FindNativeIdNoThrow(const std::vector<AssemblyExport>& list,
		const std::string name)
	{
		for (std::size_t i = 0; i < list.size(); ++i)
		{
			if (list[i].ExportName == name)
			{
				return list[i].InternalId;
			}
		}
		return SIZE_MAX;
	}

	std::size_t FindNativeIdThrow(const std::vector<AssemblyExport>& list,
		const std::string name)
	{
		auto ret = FindNativeIdNoThrow(list, name);
		if (ret == SIZE_MAX)
		{
			throw RuntimeLoaderException("Native object not found");
		}
		return ret;
	}

	Type* FindTypeTemplate(const LoadingArguments& args)
	{
		auto a = FindAssemblyThrow(args.Assembly);
		if (args.Id >= a->Types.size())
		{
			throw RuntimeLoaderException("Invalid type reference");
		}
		return &a->Types[args.Id];
	}

	Function* FindFunctionTemplate(const std::string& assembly, std::size_t id)
	{
		auto a = FindAssemblyThrow(assembly);
		if (id >= a->Functions.size())
		{
			throw RuntimeLoaderException("Invalid function reference");
		}
		return &a->Functions[id];
	}

private:
	std::shared_ptr<RuntimeFunctionCode> GetCode(const std::string& a, std::size_t id)
	{
		for (auto& c : _codeStorage.Data)
		{
			if (c->AssemblyName == a && c->Id == id)
			{
				return c;
			}
		}
		auto f = FindFunctionTemplate(a, id);
		if (f->Instruction.size() == 0 && f->ConstantData.size() == 0 &&
			f->ConstantTable.size() == 0)
		{
			return nullptr;
		}
		auto ret = std::make_shared<RuntimeFunctionCode>();
		ret->AssemblyName = a;
		ret->Id = id;
		ret->Instruction = f->Instruction;
		ret->ConstantData = f->ConstantData;
		ret->ConstantTable = f->ConstantTable;
		ret->LocalVariables = f->Locals;

		//Append some nop at the end
		for (int i = 0; i < 16; ++i)
		{
			ret->Instruction.push_back(OP_NOP);
		}

		//Process import constant
		auto assembly = FindAssemblyThrow(a);
		for (auto& k : ret->ConstantTable)
		{
			if (k.Length == 0)
			{
				auto kid = k.Offset;
				auto value = LoadImportConstant(assembly, kid);
				auto offset = ret->ConstantData.size();
				auto pValue = (unsigned char*)&value;
				ret->ConstantData.insert(ret->ConstantData.end(), pValue, pValue + 4);
				k.Length = 4;
				k.Offset = offset;
			}
		}

		_codeStorage.Data.push_back(ret);
		return std::move(ret);
	}

	void AddLoadedType(std::unique_ptr<RuntimeType> t)
	{
		SetValueInList(_loadedTypes, t->TypeId, std::move(t));
	}

	void AddLoadedFunction(std::unique_ptr<RuntimeFunction> f)
	{
		SetValueInList(_loadedFunctions, f->FunctionId, std::move(f));
	}

#endif

protected:
	//We don't expect loader to run very often. A simple spinlock
	//should be enough.
	Spinlock _loaderLock;

private:
	AssemblyList _assemblies;
	std::size_t _ptrSize, _itabPtrSize;
	std::size_t _loadingLimit;

	std::vector<std::unique_ptr<RuntimeType>> _loadedTypes;
	std::vector<std::unique_ptr<RuntimeFunction>> _loadedFunctions;
	RuntimeFunctionCodeStorage _codeStorage;

	std::vector<RuntimeType*> _loadingTypes;
	std::vector<SubtypeLoadingArguments> _loadingSubtypes;

	//Loading queues. We need to keep order.
	std::deque<std::unique_ptr<RuntimeType>> _loadingRefTypes;
	std::deque<std::unique_ptr<RuntimeType>> _postLoadingTypes;
	std::deque<std::unique_ptr<RuntimeFunction>> _loadingFunctions;
	std::deque<std::unique_ptr<RuntimeType>> _finishedLoadingTypes;
	std::deque<std::unique_ptr<RuntimeFunction>> _finishedLoadingFunctions;

	std::uint32_t _nextFunctionId = 1, _nextTypeId = 1;
	std::size_t _pointerTypeId, _boxTypeId;
};

inline std::size_t RuntimeType::GetStorageSize()
{
	return Storage == TSM_REFERENCE || Storage == TSM_INTERFACE ?
		Parent->GetPointerSize() : Size;
}

inline std::size_t RuntimeType::GetStorageAlignment()
{
	return Storage == TSM_REFERENCE || Storage == TSM_INTERFACE ?
		Parent->GetPointerSize() : Alignment;
}
